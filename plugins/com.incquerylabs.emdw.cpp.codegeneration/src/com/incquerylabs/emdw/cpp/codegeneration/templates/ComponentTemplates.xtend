package com.incquerylabs.emdw.cpp.codegeneration.templates

import com.ericsson.xtumlrt.oopl.cppmodel.CPPClass
import com.ericsson.xtumlrt.oopl.cppmodel.CPPComponent
import com.ericsson.xtumlrt.oopl.cppmodel.CPPEnumType
import com.ericsson.xtumlrt.oopl.cppmodel.CPPPackage
import com.ericsson.xtumlrt.oopl.cppmodel.CPPQualifiedNamedElement
import org.eclipse.incquery.runtime.api.IncQueryEngine
import com.ericsson.xtumlrt.oopl.cppmodel.CPPStructType

class ComponentTemplates extends CPPTemplate {
	
	public static val String ACTIVE_COMPONENT_FQN = '''«RUNTIME_NAMESPACE»::active_component'''
	
	extension val NamespaceTemplates namespaceTemplates
	extension val HeaderGuardTemplates headerGuardTemplates
	extension val IncludeTemplates includeTemplates
	extension val EnumTemplates enumTemplates
	extension val StructTemplates structTemplates
	
	new(IncQueryEngine engine) {
		super(engine)
		namespaceTemplates = new NamespaceTemplates
		headerGuardTemplates = new HeaderGuardTemplates
		includeTemplates = new IncludeTemplates
		enumTemplates = new EnumTemplates
		structTemplates = new StructTemplates
	}
	
	def componentDeclHeaderTemplate(CPPComponent cppComponent) {
		val cppComponentName = cppComponent.cppName
		val headerGuardPostfix = "DECLARATION_HEADER"
		
		'''
		/******************************************************************************
		 *
		 * C O M P O N E N T   D E C L A R A T I O N S
		 *
		 * NAME: «cppComponentName»
		 *
		 *
«««		 TODO: generated by [...]
		 *
		 ******************************************************************************/
		
		«startHeaderGuard(cppComponent, headerGuardPostfix)»
		
		«cppComponent.declarationHeaderFile.inclusions»
		
		// Forward declarations
		«cppComponent.namespaceOpenerTemplate»
			class «cppComponent.cppName»;
		«cppComponent.namespaceCloserTemplate»
		«cppComponent.forwardDeclarationsTemplate»
		
		«cppComponent.typeDefinitionsTemplate»
		
		«closeHeaderGuard(cppComponent, headerGuardPostfix)»
		'''
	}
	
	def componentDefHeaderTemplate(CPPComponent cppComponent) {
		val cppComponentName = cppComponent.cppName
		val headerGuardPostfix = "DEFINITION_HEADER"
		
		'''
		/******************************************************************************
		 *
		 * C O M P O N E N T   D E F I N I T I O N S
		 *
		 * NAME: «cppComponentName»
		 *
		 *
«««		 TODO: generated by [...]
		 *
		 ******************************************************************************/
		
		«startHeaderGuard(cppComponent, headerGuardPostfix)»
		
		«cppComponent.definitionHeaderFile.inclusions»
		
		«cppComponent.namespaceOpenerTemplate»
		
		«cppComponent.namespaceCloserTemplate»
		
		«closeHeaderGuard(cppComponent, headerGuardPostfix)»
		'''
	}
	
	def componentMainHeaderTemplate(CPPComponent cppComponent) {
		val cppComponentName = cppComponent.cppName
		val headerGuardPostfix = "MAIN_HEADER"
		
		'''
		/******************************************************************************
		 *
		 * C O M P O N E N T   M A I N   ( H E A D E R )
		 *
		 * NAME: «cppComponentName»
		 *
		 *
«««		 TODO: generated by [...]
		 *
		 ******************************************************************************/
		
		«cppComponent.startHeaderGuard(headerGuardPostfix)»
		
		«cppComponent.mainHeaderFile.inclusions»
		
		«cppComponent.namespaceOpenerTemplate»
		
		«cppComponent.componentClassInComponentMainHeader»
		
		«cppComponent.namespaceCloserTemplate»
		
		«cppComponent.closeHeaderGuard(headerGuardPostfix)»
		
		'''
	}
	
	def superclassTemplate(CPPComponent cppComponent) {
		val stateMachineMatcher = codeGenQueries.getCppComponentStateMachines(engine)
		val isActiveComponent = stateMachineMatcher.hasMatch(cppComponent, null);
		
		'''«IF isActiveComponent»: public «ACTIVE_COMPONENT_FQN» «ENDIF»'''
	}
	
	def componentMainBodyTemplate(CPPComponent cppComponent) {
		val cppComponentName = cppComponent.cppName
		
		'''
		/******************************************************************************
		 *
		 * C O M P O N E N T   M A I N   ( B O D Y )
		 *
		 * NAME: «cppComponentName»
		 *
		 *
«««		 TODO: generated by [...]
		 *
		 ******************************************************************************/
		
		«cppComponent.mainBodyFile.inclusions»
		
		«cppComponent.cppQualifiedName»::«cppComponent.cppName»* «cppComponent.cppQualifiedName»::«cppComponent.cppName»::get_instance() {
			static «cppComponent.cppQualifiedName»::«cppComponent.cppName»* instance = new «cppComponent.cppQualifiedName»::«cppComponent.cppName»();
			return instance;
		}
		
		'''
	}
	
	def componentClassInComponentMainHeader(CPPComponent cppComponent){
		'''
		class «cppComponent.cppName» «superclassTemplate(cppComponent)»{
«««		TODO: Generate component code from cppmodel 
		public:
			«cppComponent.cppName»(){}
			static «cppComponent.cppName»* get_instance();
		private:
			«cppComponent.cppName»(const «cppComponent.cppName»&);
			«cppComponent.cppName»& operator=(const «cppComponent.cppName»&);
		};
		'''
	}
	
	def CharSequence forwardDeclarationsTemplate(CPPQualifiedNamedElement cppContainer) {
		val cppClasses = cppContainer.subElements.filter(CPPClass).sortBy[cppName]
		val cppEnumTypes = <CPPEnumType>newArrayList
		if(!CPPTemplates.USE_CPP11) {
			cppEnumTypes.addAll(cppContainer.subElements.filter(CPPEnumType).sortBy[cppName])
		}
		val cppStructTypes = cppContainer.subElements.filter(CPPStructType).sortBy[cppName]
		val innerCppPackages = cppContainer.subElements.filter(CPPPackage).sortBy[cppName]
		val hasForwardDeclarations = !(cppClasses.isNullOrEmpty && cppEnumTypes.isNullOrEmpty && cppStructTypes.isNullOrEmpty)
		'''
		«IF hasForwardDeclarations»
			«cppContainer.namespaceOpenerTemplate»
				«FOR cppClass : cppClasses»
					class «cppClass.cppName»;
				«ENDFOR»
				«FOR cppEnumType : cppEnumTypes»
					class «cppEnumType.cppName»;
				«ENDFOR»
				«FOR cppStructType : cppStructTypes»
					struct «cppStructType.cppName»;
				«ENDFOR»
			«cppContainer.namespaceCloserTemplate»
		«ENDIF»
		
		«FOR innerCppPackage : innerCppPackages»
			«innerCppPackage.forwardDeclarationsTemplate»
		«ENDFOR»
		'''
	}
	
	def CharSequence typeDefinitionsTemplate(CPPQualifiedNamedElement cppContainer) {
		val cppEnumTypes = cppContainer.subElements.filter(CPPEnumType).sortBy[cppName]
		val cppStructTypes = cppContainer.subElements.filter(CPPStructType).sortBy[cppName]
		val innerCppPackages = cppContainer.subElements.filter(CPPPackage).sortBy[cppName]
		val hasTypeDefinitions = !(cppEnumTypes.isNullOrEmpty && cppStructTypes.isNullOrEmpty)
		
		'''
		// Type definitions for struct types and enums
		«IF hasTypeDefinitions»
			«cppContainer.namespaceOpenerTemplate»
				«cppContainer.cppEnumsInContainer»
				
				«cppContainer.cppStructInContainer»
			«cppContainer.namespaceCloserTemplate»
		«ENDIF»
		«FOR innerCppPackage : innerCppPackages»
			«innerCppPackage.typeDefinitionsTemplate»
		«ENDFOR»
		'''
	}
}

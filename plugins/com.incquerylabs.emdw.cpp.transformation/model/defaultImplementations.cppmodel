<?xml version="1.0" encoding="ASCII"?>
<xmi:XMI xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:cpp="http://www.ericsson.com/xtumlrt/oopl/cpp">
  <cpp:CPPSequenceImplementation anyTemplate="$valueType$ $result$ = *$collection$.begin();" addTemplate="$collection$.insert($value$);&#xD;&#xA;bool $result$ = true;" addAllTemplate="$collection$.insert($values$.begin(), $values$.end());" clearTemplate="$collection$.clear();" cloneTemplate="std::multiset&lt; $variableType$> $result$($collection$);" containsTemplate="bool $result$ = $collection$.find($value$) != $collection$.end();" containsAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;bool $result$ = true;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;if ($collection$.find(*it) == $collection$.end()) {&#xD;&#xA;&#x9;&#x9;$result$ = false;&#xD;&#xA;&#x9;&#x9;break;&#xD;&#xA;&#x9;}&#xD;&#xA;}" countOfTemplate="int $result$ = $collection$.count(e);" elementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" insertElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" isEmptyTemplate="bool $result$;&#xD;&#xA;$result$ = $collection$.empty();" removeTemplate="$collection$.erase($value$);" removeAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;    $collection$.erase(*it);&#xD;&#xA;}" replaceElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" retainAllTemplate="std::multiset&lt; $valueType$>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;    if (std::find($values$.begin(), $values$.end(), *it) == $values$.end())&#xD;&#xA;        $collection$.erase(it);&#xD;&#xA;}" sizeTemplate="unsigned int $result$ = $collection$.size();"/>
  <cpp:CPPSequenceImplementation anyTemplate="$valueType$ $result$ = *$collection$.begin();" addTemplate="std::pair&lt; std::_Rb_tree_const_iterator&lt; int>, bool> result = $collection$.insert($value$);&#xD;&#xA;bool $result$ = result.second;" addAllTemplate="$collection$.insert($values$.begin(), $values$.end());" clearTemplate="$collection$.clear();" cloneTemplate="std::set&lt; $variableType$> $result$($collection$);" containsTemplate="bool $result$ = $collection$.find($value$) != $collection$.end();" containsAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;bool $result$ = true;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;if ($collection$.find(*it) == $collection$.end()) {&#xD;&#xA;&#x9;&#x9;$result$ = false;&#xD;&#xA;&#x9;&#x9;break;&#xD;&#xA;&#x9;}&#xD;&#xA;}" countOfTemplate="int $result$ = $collection$.count(e);" elementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" insertElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" isEmptyTemplate="bool $result$ = $collection$.empty();" removeTemplate="$collection$.erase($value$);" removeAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;    $collection$.erase(*it);&#xD;&#xA;}" replaceElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" retainAllTemplate="std::set&lt; $valueType$>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;    if (std::find($values$.begin(), $values$.end(), *it) == $values$.end())&#xD;&#xA;        $collection$.erase(it);&#xD;&#xA;}" sizeTemplate="unsigned int $result$ = $collection$.size();" uniqueness="UNIQUE"/>
  <cpp:CPPSequenceImplementation anyTemplate="$valueType$ $result$ = $collection$.front();" addTemplate="$collection$.push_back(e);&#xD;&#xA;bool $result$ = true;" addAllTemplate="$collection$.insert($collection$.end(), $values$.begin(), $values$.end());" clearTemplate="$collection$.clear();" cloneTemplate="std::vector&lt; $variableType$> $result$($collection$);" containsTemplate="bool $result$ = std::find($collection$.begin(), $collection$.end(), $value$) != $collection$.end();" containsAllTemplate="$valuesType$&lt; $valueType>::iterator it;&#xD;&#xA;bool $result$ = true;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;if (std::find($collection$.begin(), $collection$.end(), *it) == $collection$.end()) {&#xD;&#xA;&#x9;&#x9;$result$ = false;&#xD;&#xA;&#x9;&#x9;break;&#xD;&#xA;&#x9;}&#xD;&#xA;}" countOfTemplate="unsigned int $result$ = $collection$.count(e);" elementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" insertElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" isEmptyTemplate="bool $result$ = $collection$.empty();" removeTemplate="$collection$.erase($value$);" removeAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;    $collection$.erase(*it);&#xD;&#xA;}" replaceElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" retainAllTemplate="std::vector&lt; $valueType$>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;    if (std::find($values$.begin(), $values$.end(), *it) == $values$.end())&#xD;&#xA;        $collection$.erase(it);&#xD;&#xA;}" sizeTemplate="unsigned int $result$ = $collection$.size();" orderedness="ORDERED"/>
  <cpp:CPPClassRefSimpleCollectionImplementation anyTemplate="$valueType$ $result$ = $collection$.front();" addTemplate="$collection$.push_back($value$);&#xD;&#xA;bool $result$ = true;" addAllTemplate="$collection$.insert($collection$.end(), $values$.begin(), $values$.end());" clearTemplate="$collection$.clear();" cloneTemplate="std::list&lt; $valueType$> $result$($collection$);" containsTemplate="bool $result$ = std::find($collection$.begin(), $collection$.end(), $value$) != $collection$.end();" containsAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;bool $result$ = true;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;if (std::find($collection$.begin(), $collection$.end(), *it) == $collection$.end()) {&#xD;&#xA;&#x9;&#x9;$result$ = false;&#xD;&#xA;&#x9;&#x9;break;&#xD;&#xA;&#x9;}&#xD;&#xA;}" countOfTemplate="unsigned int $result$ = std::count($collection$.begin(), $collection$.end(), $value$);" elementAtIndexTemplate="std::list&lt; $valueType$>::iterator it = $collection$.begin();&#xD;&#xA;std::advance(it, $index$);&#xD;&#xA;$valueType$ $result$ = *it;" insertElementAtIndexTemplate="std::list&lt; $valueType$>::iterator it = $collection$.begin();&#xD;&#xA;std::advance(it, $index$);&#xD;&#xA;$collection$.insert(it, $value$);" isEmptyTemplate="bool $result$ = $collection$.empty();" removeTemplate="$collection$.erase(std::remove($collection$.begin(), $collection$.end(), $value$), $collection$.end());" removeAllTemplate="$valuesType$&lt; $valueType>::iterator it;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;$collection$.erase(std::remove($collection$.begin(), $collection$.end(), *it), $collection$.end());&#xD;&#xA;}" replaceElementAtIndexTemplate="std::list&lt; int>::iterator it = $collection$.begin();&#xD;&#xA;std::advance(it, $index$);&#xD;&#xA;$collection$.insert($collection$.erase(it), $value$);" retainAllTemplate="std::list&lt; int>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;&#x9;if (std::find($values$.begin(), $values$.end(), *it) == $values$.end())&#xD;&#xA;&#x9;$collection$.erase(it);&#xD;&#xA;}" sizeTemplate="unsigned int $result$ = $collection$.size();"/>
  <cpp:CPPClassRefSimpleCollectionImplementation anyTemplate="$variableType$ $result$ = $collection$.front();" addTemplate="$collection$.push_back($value$);&#xD;&#xA;bool $result$ = true;" addAllTemplate="$collection$.insert($collection$.end(), $values$.begin(), $values$.end());" clearTemplate="$collection$.clear();" cloneTemplate="std::list&lt; $valueType$> $result$($collection$);" containsTemplate="bool $result$ = std::find($collection$.begin(), $collection$.end(), $value$) != $collection$.end();" containsAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;bool $result$ = true;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;if (std::find($collection$.begin(), $collection$.end(), *it) == $collection$.end()) {&#xD;&#xA;&#x9;&#x9;$result$ = false;&#xD;&#xA;&#x9;&#x9;break;&#xD;&#xA;&#x9;}&#xD;&#xA;}" countOfTemplate="unsigned int $result$ = std::count($collection$.begin(), $collection$.end(), $value$);" elementAtIndexTemplate="std::list&lt; $valueType$>::iterator it = $collection$.begin();&#xD;&#xA;std::advance(it, $index$);&#xD;&#xA;$valueType$ $result$ = *it;" insertElementAtIndexTemplate="std::list&lt; $valueType$>::iterator it = $collection$.begin();&#xD;&#xA;std::advance(it, $index$);&#xD;&#xA;$collection$.insert(it, $value$);" isEmptyTemplate="bool $result$ = $collection$.empty();" removeTemplate="$collection$.erase(std::remove($collection$.begin(), $collection$.end(), $value$), $collection$.end());" removeAllTemplate="$valuesType$&lt; $valueType>::iterator it;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;$collection$.erase(std::remove($collection$.begin(), $collection$.end(), *it), $collection$.end());&#xD;&#xA;}" replaceElementAtIndexTemplate="std::list&lt; int>::iterator it = $collection$.begin();&#xD;&#xA;std::advance(it, $index$);&#xD;&#xA;$collection$.insert($collection$.erase(it), $value$);" retainAllTemplate="std::list&lt; int>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;&#x9;if (std::find($values$.begin(), $values$.end(), *it) == $values$.end())&#xD;&#xA;&#x9;$collection$.erase(it);&#xD;&#xA;}" sizeTemplate="unsigned int $result$ = $collection$.size();" kind="DOUBLY_LINKED_LIST"/>
  <cpp:CPPClassRefSimpleCollectionImplementation anyTemplate="$valueType$ $result$ = $collection$.front();" addTemplate="$collection$.push_back($value$);&#xD;&#xA;bool $result$ = true;" addAllTemplate="$collection$.insert($collection$.end(), $values$.begin(), $values$.end());" clearTemplate="$collection$.clear();" cloneTemplate="std::deque&lt; $valueType$> $result$($collection$);" containsTemplate="bool $result$ = std::find($collection$.begin(), $collection$.end(), $value$) != $collection$.end();" containsAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;bool $result$ = true;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;if (std::find($collection$.begin(), $collection$.end(), *it) == $collection$.end()) {&#xD;&#xA;&#x9;&#x9;$result$ = false;&#xD;&#xA;&#x9;&#x9;break;&#xD;&#xA;&#x9;}&#xD;&#xA;}" countOfTemplate="unsigned int $result$ = std::count($collection$.begin(), $collection$.end(), $value$);" elementAtIndexTemplate="$valueType$ $result$ = $collection$[position];" insertElementAtIndexTemplate="std::deque&lt; int>::iterator it = $collection$.begin();&#xD;&#xA;std::advance(it, position);&#xD;&#xA;$collection$.insert(it, e);" isEmptyTemplate="$result$ = $collection$.empty();" removeTemplate="$collection$.erase(std::remove($collection$.begin(), $collection$.end(), $value$), $collection$.end());" removeAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;$collection$.erase(std::remove($collection$.begin(), $collection$.end(), *it), $collection$.end());&#xD;&#xA;}" replaceElementAtIndexTemplate="std::list&lt; int>::iterator it = $collection$.begin();&#xD;&#xA;std::advance(it, $index$);&#xD;&#xA;$collection$.insert($collection$.erase(it), $value$);" retainAllTemplate="std::list&lt; int>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;&#x9;if (std::find($values$.begin(), $values$.end(), *it) == $values$.end())&#xD;&#xA;&#x9;$collection$.erase(it);&#xD;&#xA;}" sizeTemplate="unsigned int $result$ = $collection$.size();" kind="DOUBLE_ENDED_QUEUE"/>
  <cpp:CPPClassRefAssocCollectionImplementation anyTemplate="$valueType$ $result$ = *$collection$.begin();" addTemplate="std::pair&lt; std::_Rb_tree_const_iterator&lt; int>, bool> result = $collection$.insert($value$);&#xD;&#xA;bool $result$ = result.second;" addAllTemplate="$collection$.insert($values$.begin(), $values$.end());" clearTemplate="$collection$.clear();" cloneTemplate="std::set&lt; $variableType$> $result$($collection$);" containsTemplate="bool $result$ = $collection$.find($value$) != $collection$.end();" containsAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;bool $result$ = true;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;if ($collection$.find(*it) == $collection$.end()) {&#xD;&#xA;&#x9;&#x9;$result$ = false;&#xD;&#xA;&#x9;&#x9;break;&#xD;&#xA;&#x9;}&#xD;&#xA;}" countOfTemplate="int $result$ = $collection$.count(e);" elementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" insertElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" isEmptyTemplate="bool $result$ = $collection$.empty();" removeTemplate="$collection$.erase($value$);" removeAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;    $collection$.erase(*it);&#xD;&#xA;}" replaceElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" retainAllTemplate="std::set&lt; $valueType$>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;    if (std::find($values$.begin(), $values$.end(), *it) == $values$.end())&#xD;&#xA;        $collection$.erase(it);&#xD;&#xA;}" sizeTemplate="unsigned int $result$ = $collection$.size();" kind="ORDERED_SET"/>
  <cpp:CPPClassRefAssocCollectionImplementation anyTemplate="$valueType$ $result$ = *$collection$.begin();" addTemplate="$collection$.insert($value$);&#xD;&#xA;bool $result$ = true;" addAllTemplate="$collection$.insert($values$.begin(), $values$.end());" clearTemplate="$collection$.clear();" cloneTemplate="std::multiset&lt; $valueType$> $result$($collection$);" containsTemplate="bool $result$ = $collection$.find($value$) != $collection$.end();" containsAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;bool $result$ = true;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;if ($collection$.find(*it) == $collection$.end()) {&#xD;&#xA;&#x9;&#x9;$result$ = false;&#xD;&#xA;&#x9;&#x9;break;&#xD;&#xA;&#x9;}&#xD;&#xA;}" countOfTemplate="int $result$ = $collection$.count(e);" elementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" insertElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" isEmptyTemplate="bool $result$;&#xD;&#xA;$result$ = $collection$.empty();" removeTemplate="$collection$.erase($value$);" removeAllTemplate="$valuesType$&lt; $valueType$>::iterator it;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;    $collection$.erase(*it);&#xD;&#xA;}" replaceElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of set)" retainAllTemplate="std::multiset&lt; $valueType$>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;    if (std::find($values$.begin(), $values$.end(), *it) == $values$.end())&#xD;&#xA;        $collection$.erase(it);&#xD;&#xA;}" sizeTemplate="unsigned int $result$ = $collection$.size();" kind="ORDERED_MULTISET"/>
  <cpp:CPPClassRefAssocCollectionImplementation anyTemplate="$valueType$ $result$ = (*$collection$.begin()).second;" addTemplate="$collection$.insert(std::make_pair($key$, $value$));&#xD;&#xA;bool $result$ = true;" addAllTemplate="$collection$.insert($values$.begin(), $values$.end());" clearTemplate="$collection$.clear();" cloneTemplate="std::multimap&lt; $keyType$, $valueType$> $result$($collection$);" containsTemplate="bool $result$ = $collection$.find($key$) != $collection$.end();" containsAllTemplate="$valueTypes$&lt; $valueType$>::iterator it;&#xD;&#xA;bool $result$ = true;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;if ($collection$.find(*it) == $collection$.end()) {&#xD;&#xA;&#x9;&#x9;$result$ = false;&#xD;&#xA;&#x9;&#x9;break;&#xD;&#xA;&#x9;}&#xD;&#xA;}" countOfTemplate="unsigned int $result$ = $collection$.count($key$);" elementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of map)" insertElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of map)" isEmptyTemplate="bool $result$ = $collection$.empty();" removeTemplate="$collection$.erase($value$);" removeAllTemplate="std::multimap&lt; $keyType$, $valueType$>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;&#x9;if (std::find($values$.begin(), $values$.end(), (*it).first) != $values$.end())&#xD;&#xA;&#x9;&#x9;$collection$.erase(it);&#xD;&#xA;}" replaceElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of map)" retainAllTemplate="std::multimap&lt; int, int>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;&#x9;if (std::find(keysequence.begin(), keysequence.end(), (*it).first) == keysequence.end())&#xD;&#xA;&#x9;&#x9;$collection$.erase(it);&#xD;&#xA;}" sizeTemplate="unsigned int $result$ = $collection$.size();" kind="ORDERED_MULTIMAP"/>
  <cpp:CPPClassRefAssocCollectionImplementation anyTemplate="$valueType$ $result$ = (*$collection$.begin()).second;" addTemplate="std::pair&lt; std::_Rb_tree_iterator&lt; std::pair&lt; const $keyType$, $valueType$> >, bool> result = map.insert(std::make_pair($key$, $value$));&#xD;&#xA;bool $result$ = result.second;" addAllTemplate="$collection$.insert($values$.begin(), $values$.end());" clearTemplate="$collection$.clear();" cloneTemplate="std::map&lt; $keyType$, $valueType$> $result$($collection$);" containsTemplate="bool $result$ = $collection$.find($key$) != $collection$.end();" containsAllTemplate="$valueTypes$&lt; $valueType$>::iterator it;&#xD;&#xA;bool $result$ = true;&#xD;&#xA;for (it = $values$.begin(); it != $values$.end(); it++) {&#xD;&#xA;&#x9;if ($collection$.find(*it) == $collection$.end()) {&#xD;&#xA;&#x9;&#x9;$result$ = false;&#xD;&#xA;&#x9;&#x9;break;&#xD;&#xA;&#x9;}&#xD;&#xA;}" countOfTemplate="unsigned int $result$ = $collection$.count($key$);" elementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of map)" insertElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of map)" isEmptyTemplate="bool $result$ = $collection$.empty();" removeTemplate="$collection$.erase($value$);" removeAllTemplate="std::map&lt; $keyType$, $valueType$>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;&#x9;if (std::find($values$.begin(), $values$.end(), (*it).first) != $values$.end())&#xD;&#xA;&#x9;&#x9;$collection$.erase(it);&#xD;&#xA;}" replaceElementAtIndexTemplate="// Unsupported operation (the concept of index makes no sense in case of map)" retainAllTemplate="std::map&lt; int, int>::iterator it;&#xD;&#xA;for (it = $collection$.begin(); it != $collection$.end(); it++) {&#xD;&#xA;&#x9;if (std::find(keysequence.begin(), keysequence.end(), (*it).first) == keysequence.end())&#xD;&#xA;&#x9;&#x9;$collection$.erase(it);&#xD;&#xA;}" sizeTemplate="unsigned int $result$ = $collection$.size();" kind="ORDERED_MAP"/>
</xmi:XMI>

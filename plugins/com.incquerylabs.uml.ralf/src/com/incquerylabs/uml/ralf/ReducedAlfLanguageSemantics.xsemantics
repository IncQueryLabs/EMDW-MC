system com.incquerylabs.uml.ralf.ReducedAlfSystem

validatorExtends AbstractReducedAlfLanguageValidator

import com.incquerylabs.uml.ralf.reducedAlfLanguage.ArithmeticExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.AssignmentExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.AssociationAccessExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.BooleanLiteralExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.BooleanUnaryExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ConditionalLogicalExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ConditionalTestExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FilterVariable
import com.incquerylabs.uml.ralf.reducedAlfLanguage.DoStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ElementCollectionExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.EqualityExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Expression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FeatureLeftHandSide
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FilterExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ForStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.InstanceCreationExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.LinkOperation
import com.incquerylabs.uml.ralf.reducedAlfLanguage.LinkOperationExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.LocalNameDeclarationStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.LogicalExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.LoopVariable
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NameExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NameLeftHandSide
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NaturalLiteralExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NonFinalClause
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NumericUnaryExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.PostfixExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.PrefixExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.PropertyAccessExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.RealLiteralExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.RelationalExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.SendSignalStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ShiftExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.StringLiteralExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.SwitchClause
import com.incquerylabs.uml.ralf.reducedAlfLanguage.SwitchStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ThisExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.TypeDeclaration
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Variable
import com.incquerylabs.uml.ralf.reducedAlfLanguage.WhileStatement
import com.incquerylabs.uml.ralf.scoping.IUMLContextProvider
import com.incquerylabs.uml.ralf.types.CollectionTypeReference
import com.incquerylabs.uml.ralf.types.IUMLTypeReference
import com.incquerylabs.uml.ralf.types.IUMLTypeReference.AnyTypeReference
import com.incquerylabs.uml.ralf.types.IUMLTypeReference.NullTypeReference
import com.incquerylabs.uml.ralf.types.TypeFactory
import com.incquerylabs.uml.ralf.types.UMLTypeReference
import com.incquerylabs.uml.ralf.validation.AbstractReducedAlfLanguageValidator
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.uml2.uml.Class
import org.eclipse.uml2.uml.Classifier
import org.eclipse.uml2.uml.PrimitiveType
import org.eclipse.uml2.uml.Signal
import org.eclipse.uml2.uml.Type
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ForEachStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NullExpression
import com.incquerylabs.uml.ralf.types.AbstractTypeReference
import org.eclipse.uml2.uml.Parameter
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ReturnStatement
import com.incquerylabs.uml.ralf.scoping.UMLScopeHelper
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FeatureInvocationExpression
import org.eclipse.uml2.uml.Operation
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Tuple
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NamedTuple
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ExpressionList
import com.incquerylabs.uml.ralf.reducedAlfLanguage.InstanceDeletionExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.StaticFeatureInvocationExpression

inject extension IUMLContextProvider umlContext
inject extension TypeFactory typeFactory
inject extension UMLScopeHelper scopeHelper

val REAL    = IUMLContextProvider.REAL_TYPE
val INTEGER = IUMLContextProvider.INTEGER_TYPE
val BOOLEAN = IUMLContextProvider.BOOLEAN_TYPE
val STRING  = IUMLContextProvider.STRING_TYPE

auxiliary {
    superClassList(Class cl) : List<Class>
    typeReference(TypeDeclaration decl) : IUMLTypeReference 
}

judgments {
    type |- EObject expression : output IUMLTypeReference
        error "Cannot type " + stringRep(expression)
        source expression
    operationType |- Operation op <: Tuple params : output IUMLTypeReference
        error "Invalid parameter types " + stringRep(op)
        source op
    subtypeReference |- IUMLTypeReference left <: IUMLTypeReference right
        error stringRep(left) + " is not a subtype of  " + stringRep(right)
    subtypeOrEqual |- Type left <~ Type right
        error stringRep(left) + " is not a subtype of  " + stringRep(right)
    assignable |- Expression expression |> IUMLTypeReference target
        error stringRep(expression) + " is not assignable for type " + stringRep(target)
        source expression        
}

auxiliary superClassList(Class cl) {
    cl.superClasses
}

auxiliary typeReference(TypeDeclaration decl) {
//    if (decl.isIsAny) {
//        anyType
//    } else {
        decl.getType().typeReference
//    }
}

axiom BooleanLiteral
    G |- BooleanLiteralExpression bool :
        BOOLEAN.primitiveTypeReference
        
axiom NaturalLiteral
    G |- NaturalLiteralExpression natural :
        INTEGER.primitiveTypeReference
        
axiom RealLiteral
    G |- RealLiteralExpression real :
        REAL.primitiveTypeReference
        
axiom StringLiteral
    G |- StringLiteralExpression string :
        STRING.primitiveTypeReference

axiom NullLiteral
    G |- NullExpression ex : nullType


/**
 * Variable declarations
 */
rule TypeDeclaration
    G |- TypeDeclaration typeDecl: IUMLTypeReference result
        
from {
    result = typeDecl.typeReference
}


rule VariableDeclaration
    derives G |- Variable variable : IUMLTypeReference result
from {
      result = variable.type.typeReference
}

rule LoopVariable
    derives G |- LoopVariable variable : IUMLTypeReference result
from {
    if (variable.type != null) {
        result = variable.type.typeReference
    } 
}

rule FilterVariable
    derives G |- FilterVariable variable : IUMLTypeReference result
from {
    if (variable.type != null) {
        result = variable.type.typeReference
    }else{
    	var filterExp = variable.eContainer as FilterExpression
    	G |- filterExp.context : var CollectionTypeReference contextType
    	result = contextType.valueType
    } 
}

rule Parameter
    derives G |- Parameter parameter : IUMLTypeReference result
from {
    result = parameter.type.typeReference
}

rule Type
    derives G |- Type type : IUMLTypeReference result
from {
    result = type.typeReference
}
/**
 * Subtyping and assignability
 */  

axiom NullSubtyping
  G |- UMLTypeReference left <: NullTypeReference right
  
axiom AnySubtyping
  G |- AnyTypeReference left <: IUMLTypeReference right

rule GeneralReferenceSubtyping 
    derives G |- IUMLTypeReference left <: IUMLTypeReference right
    error "The type " + stringRep(left) + " is not compatible with the type " + stringRep(right)
from {
    //More specific cases are not matched, fail here
    fail
} 

rule SimpleTypeReferenceSubtyping
    derives G |- AbstractTypeReference left <: AbstractTypeReference right
from {
    G |- left.umlType <~ right.umlType
}

rule CollectionSubtyping
    derives G |- CollectionTypeReference left <: CollectionTypeReference right
from {
    left.type == right.type
    left.valueType == right.valueType
}

rule GeneralSubtyping
    derives G |- Type left <~ Type right
    error "The type " + stringRep(left) + " is not compatible with the type " + stringRep(right)
from {
    //More specific cases are not matched, fail here
    fail
}  

rule PrimitiveSubtyping
    derives G |- PrimitiveType left <~ PrimitiveType right
from {
    {
        left == right
    } or {
        left == REAL.primitiveType
        right == INTEGER.primitiveType
    }
}

rule EqualsClassifierSubtyping
    derives G |- Classifier left <~ Classifier right
from {
    left == right
}

rule ClassSubtyping
    derives G |- Class left <~ Class right
from {
    left == right
    or
    right.name == "Object"
    or
    superClassList(left).contains(right)
} 

rule ExpressionAssignableToType
    G |- Expression ex |> IUMLTypeReference target
from {
    G |- ex : var IUMLTypeReference expressionType
    G |- expressionType <: target 
}

/**
 * Operation typing
 */
rule OperationTyping
    G |- Operation op <: Tuple params : IUMLTypeReference result
from {
    fail
}
rule ParameterListTyping
    G |- Operation op <: ExpressionList params : IUMLTypeReference result
from {
    val opParamLength = op.ownedParameters.size
    val paramLength = params.expressions.size
    opParamLength == paramLength
    
    for (var i = 0; i < paramLength; i++) {
        val declaredType = op.ownedParameters.get(i).type.typeReference
        G |- params.expressions.get(i) |> declaredType
    }
    
    G |- op : result
}
rule NamedTupleTyping
    G |- Operation op <: NamedTuple params : IUMLTypeReference result
from {
    
    result = op.returnParameter.type.typeReference
}

/**
 * Expression typing
 */  
rule NumericUnaryExpression
    G |- NumericUnaryExpression ex : IUMLTypeReference result
from {
    {
        ex.operand.type.value == INTEGER.primitiveTypeReference
        result = INTEGER.primitiveTypeReference
    } or {
        ex.operand.type.value == REAL.primitiveTypeReference
        result = REAL.primitiveTypeReference
    }
}

rule ArithmeticExpression
    G |- ArithmeticExpression ex : IUMLTypeReference result
from {
   G |- ex.operand1 : var IUMLTypeReference type1
   G |- ex.operand2 : var IUMLTypeReference type2  
   { 
       ex.operator == "+"
       type1 == STRING.primitiveTypeReference
       type2 == STRING.primitiveTypeReference
       result = STRING.primitiveTypeReference
   } or {
       ex.operator == "+"
       type1 == REAL.primitiveTypeReference
       type2 == REAL.primitiveTypeReference || type2 == INTEGER.primitiveTypeReference
       result = REAL.primitiveTypeReference
   } or {
       ex.operator == "+"
       type1 == REAL.primitiveTypeReference || type1 == INTEGER.primitiveTypeReference
       type2 == REAL.primitiveTypeReference
       result = REAL.primitiveTypeReference
   } or {
       type1 == REAL.primitiveTypeReference
       type2 == INTEGER.primitiveTypeReference || type2 == REAL.primitiveTypeReference
       result = REAL.primitiveTypeReference
   } or {
       type1 == INTEGER.primitiveTypeReference || type1 == REAL.primitiveTypeReference
       type2 == REAL.primitiveTypeReference
       result = REAL.primitiveTypeReference
   } or {
       //All operations
       type1 == INTEGER.primitiveTypeReference
       type2 == INTEGER.primitiveTypeReference
       result = INTEGER.primitiveTypeReference
   }
} 

rule NameExpression
    G |- NameExpression ex : IUMLTypeReference result
from {
    G |- ex.reference : var IUMLTypeReference varType
    result = varType
}

rule FilterExpression
    G |- FilterExpression ex : IUMLTypeReference result
from {
	G |- ex.declaration : var IUMLTypeReference declarationType
    G |- ex.expression : var IUMLTypeReference expType
    G |- ex.context : var CollectionTypeReference contextType
    
	G |- contextType.valueType <: declarationType
    expType == BOOLEAN.primitiveTypeReference
    result = contextType
}

rule AssignmentExpression
    G |- AssignmentExpression ex : IUMLTypeReference result
from {
    G |- ex.leftHandSide : var IUMLTypeReference leftType
    G |- ex.rightHandSide : var IUMLTypeReference rightType
    G |- leftType <: rightType
    result = rightType
}

rule PrefixExpression
    G |- PrefixExpression ex : IUMLTypeReference result
from {
    G |- ex.operand : var IUMLTypeReference opType
    opType == INTEGER.primitiveTypeReference
    result = INTEGER.primitiveTypeReference
}

rule PostfixExpression
    G |- PostfixExpression ex : IUMLTypeReference result
from {
    G |- ex.operand : var IUMLTypeReference opType
    opType == INTEGER.primitiveTypeReference
    result = INTEGER.primitiveTypeReference
}

rule ShiftExpression
    G |- ShiftExpression ex : IUMLTypeReference result
from {
   G |- ex.operand1 : var IUMLTypeReference op1Type 
   G |- ex.operand2 : var IUMLTypeReference op2Type
   op1Type == INTEGER.primitiveTypeReference
   op2Type == INTEGER.primitiveTypeReference
   result   = INTEGER.primitiveTypeReference
}

rule EqualityExpression
    G |- EqualityExpression ex : IUMLTypeReference result
from {
    G |- ex.operand1 : var IUMLTypeReference op1Type 
    G |- ex.operand2 : var IUMLTypeReference op2Type
    {
        G |- op1Type <: op2Type
        or
        G |- op2Type <: op1Type
    } 
    result = BOOLEAN.primitiveTypeReference
}

rule RelationalExpression
    G |- RelationalExpression ex : IUMLTypeReference result
from {
    G |- ex.operand1 : var IUMLTypeReference op1Type 
    G |- ex.operand2 : var IUMLTypeReference op2Type
    op1Type == INTEGER.primitiveTypeReference || op1Type == REAL.primitiveTypeReference 
    op2Type == INTEGER.primitiveTypeReference || op2Type == REAL.primitiveTypeReference
    result = BOOLEAN.primitiveTypeReference
}

rule LogicalUnaryExpression
    G |- BooleanUnaryExpression ex : IUMLTypeReference result
from {
    G |- ex.operand : var IUMLTypeReference opType
    opType == BOOLEAN.primitiveTypeReference
    result = BOOLEAN.primitiveTypeReference
}

rule LogicalExpression
    G |- LogicalExpression ex : IUMLTypeReference result
from {
    G |- ex.operand1 : var IUMLTypeReference op1Type 
    G |- ex.operand2 : var IUMLTypeReference op2Type
    {
        op1Type == BOOLEAN.primitiveTypeReference
        op2Type == BOOLEAN.primitiveTypeReference
        result = BOOLEAN.primitiveTypeReference
    } or {
        op1Type == INTEGER.primitiveTypeReference
        op2Type == INTEGER.primitiveTypeReference
        result = INTEGER.primitiveTypeReference
    }
}

rule ConditionalLogicalExpression
    G |- ConditionalLogicalExpression ex : IUMLTypeReference result
from {
    G |- ex.operand1 : var IUMLTypeReference op1Type 
    G |- ex.operand2 : var IUMLTypeReference op2Type
    op1Type == BOOLEAN.primitiveTypeReference
    op2Type == BOOLEAN.primitiveTypeReference
    result = BOOLEAN.primitiveTypeReference
}

rule ConditionalTestExpression
    G |- ConditionalTestExpression ex : IUMLTypeReference result
from {
    G |- ex.operand1 : var IUMLTypeReference condType
    G |- ex.operand2 : var IUMLTypeReference trueType
    G |- ex.operand3 : var IUMLTypeReference falseType
    G |- trueType <: falseType 
    condType == BOOLEAN.primitiveTypeReference
    result = trueType
}


rule InstanceCreationExpression
    G |- InstanceCreationExpression ex : IUMLTypeReference result
from {
    // Primitive types cannot be instantiated
    !(ex.instance instanceof PrimitiveType)
    
    // TODO Parameter mapping
    ex.tuple
    
    // Return typing
    result = ex.instance.typeReference
}


rule InstanceDeletionExpression
    G |- InstanceDeletionExpression ex : IUMLTypeReference result
from {
    G |- ex.reference : var UMLTypeReference refType
    // Primitive types cannot be deleted
    !(refType.umlType instanceof PrimitiveType)
    
    result = voidType
}

rule ThisExpression
    G |- ThisExpression ex : IUMLTypeReference result
from {
    if (umlContext.thisType == null) {
        result = anyType
    } else {
        result = umlContext.thisType.typeReference
    }
}

rule PropertyAccessExpression
    G |- PropertyAccessExpression ex : IUMLTypeReference result
from {
    {
        !ex.property.multivalued
        result = ex.property.type.typeReference
    } or {
        ex.property.multivalued && ex.property.ordered 
        result = ex.property.type.sequenceOf
    } or {
        ex.property.multivalued && !ex.property.ordered && ex.property.unique
        result = ex.property.type.setOf
    } or {
        ex.property.multivalued && !ex.property.ordered && !ex.property.unique
        result = ex.property.type.bagOf
    }
}

rule AssociationAccessExpression
    G |- AssociationAccessExpression ex : IUMLTypeReference result
from {
    result = ex.association.type.typeReference
}

rule LinkOperationExpression
    G |- LinkOperationExpression ex : IUMLTypeReference result
from {
    {
        ex.operation == LinkOperation.LINK
        result = ex.association.typeReference
    }  or {
        result = null
    } 
}

rule CollectionConstructionExpression
    derives G |- ElementCollectionExpression ex : IUMLTypeReference result
from {
    val valueType = if (ex.typeDeclaration != null) {
        ex.typeDeclaration.typeReference
    } else {
        anyType
    }
    
    for (element : ex.elements.expressions) {
        G |- element : var IUMLTypeReference elType
        G |- valueType <: elType
    }
    if (ex.collectionType != null) {
        result = valueType.collectionOf(ex.collectionType)
    } else {
        result = valueType.sequenceOf   
    }
}

rule FeatureInvocationExpression
    derives G |- FeatureInvocationExpression ex : IUMLTypeReference result
from {
    G |- ex.operation : result
    //TODO parameter typing
}

rule StaticFeatureInvocationExpression
    derives G |- StaticFeatureInvocationExpression ex : IUMLTypeReference result
from {
    G |- ex.operation : result
    //TODO parameter typing
}

rule Operation
    derives G |- Operation op : IUMLTypeReference result
from {
    {
        op.getType == null
        result = voidType 
    } or {
        result = op.getType.typeReference
    }
}

//Non-expression types

rule FeatureLeftHandSide
    G |- FeatureLeftHandSide lhs : IUMLTypeReference result
from {
    G |- lhs.expression : var IUMLTypeReference exType
    result = exType
}

rule NameLeftHandSide
    G |- NameLeftHandSide lhs : IUMLTypeReference result
from {
    {
        lhs.index == null
        G |- lhs.expression : var IUMLTypeReference varType
        result = varType
    } or {
        G |- lhs.expression : var AbstractTypeReference varType
        result = varType.umlType.bagOf
    }
}


/**
 * Validation rules
 */

checkrule CheckExpressionType for
    Expression ex
from {
    empty |- ex : var IUMLTypeReference type
}

checkrule VariableType for
    Variable ^var
from {
    empty |- ^var : var IUMLTypeReference type
}

checkrule LocalNameDeclarationStatementType for
    LocalNameDeclarationStatement st
from {
    empty |- st.variable : var IUMLTypeReference varType
    if(st.expression != null){
    	empty |- st.expression : var IUMLTypeReference valueType
    	empty |- varType <: valueType
    }
       
}

checkrule NonFinalClause for
    NonFinalClause cl
from {
    empty |- cl.^condition : var IUMLTypeReference condType
    empty |- condType <: BOOLEAN.primitiveTypeReference
}

checkrule ForStatement for
    ForStatement st
from {
    empty |- st.^condition : var IUMLTypeReference condType
    empty |- condType <: BOOLEAN.primitiveTypeReference
}

checkrule ForEachStatement for
    ForEachStatement st
from {
    empty |- st.expression  : var IUMLTypeReference exType
	empty |- st.variableDefinition  : var IUMLTypeReference defType
	if(exType instanceof CollectionTypeReference){
		empty |- exType.valueType <: defType
	}else{
		fail
        error "Invalid collection type "
	}
}

checkrule WhileStatement for
    WhileStatement st
from {
    empty |- st.^condition : var IUMLTypeReference condType
    empty |- condType <: BOOLEAN.primitiveTypeReference
}

checkrule DoStatement for
    DoStatement st
from {
    empty |- st.^condition : var IUMLTypeReference condType
    empty |- condType <: BOOLEAN.primitiveTypeReference
}

checkrule SwitchStatement_ for
    SwitchStatement st
from {
    //Proper type
    empty |- st.expression : var IUMLTypeReference eType
    {
        INTEGER.primitiveTypeReference == eType
    } or {
        STRING.primitiveTypeReference == eType
    }
    //cases match the type
    for(SwitchClause cl : st.nonDefaultClause){
        for(Expression ex : cl.^case){
            empty |- ex : var IUMLTypeReference caseType
            empty |- st.expression |> caseType
        }
    }
    
}

checkrule SendSignalStatement for
    SendSignalStatement st
from {
    empty |- st.signal : var UMLTypeReference signalType
    empty |- st.target : var UMLTypeReference targetType
    if (!(signalType.umlType instanceof Signal)) {
        fail
        error "Invalid signal type " + signalType.umlType.name
    }
    if (!(targetType.umlType instanceof Class)) {
        fail
        error "Invalid signal target " + targetType.umlType.name
    }
}

checkrule ReturnStatement for
    ReturnStatement st
from {
    val returnValue = definedOperation.returnParameter
    {
        returnValue == null    
        st.expression == null
    } or {
        returnValue != null    
        st.expression != null
        empty |- st.expression : var IUMLTypeReference exprType
        val returnType = returnValue.type.typeReference
        empty |- returnType <: exprType
    } or {
        returnValue == null    
        st.expression != null
        fail
            error "Unexpected return value " + st.expression.stringRep
            source st.expression
    }
}

checkrule OperationParameters for 
    FeatureInvocationExpression ex
from {
    
}
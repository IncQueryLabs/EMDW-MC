/*
 * generated by Xtext
 */
package com.incquerylabs.uml.ralf.scoping

import com.google.inject.Inject
import com.incquerylabs.uml.ralf.ReducedAlfSystem
import com.incquerylabs.uml.ralf.reducedAlfLanguage.AssociationAccessExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Block
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Expression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.PropertyAccessExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Statement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Statements
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Variable
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.uml2.uml.Class
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import com.incquerylabs.uml.ralf.types.UMLTypeReference
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ForStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FeatureInvocationExpression
import com.incquerylabs.uml.ralf.types.IUMLTypeReference
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ForEachStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FilterExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.StaticFeatureInvocationExpression
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.naming.IQualifiedNameConverter

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
 
class ReducedAlfLanguageScopeProvider extends AbstractDeclarativeScopeProvider {

    @Inject
    IUMLContextProvider umlContext
    @Inject
    ReducedAlfSystem system
    @Inject
    IQualifiedNameConverter nameConverter
    
//    override getPredicate(EObject context, EClass type) {
//        val methodName = "scope_" + type.name
//        println(methodName + " with context " + context.eClass.name)
//        return PolymorphicDispatcher.Predicates.forName(methodName, 2)
//    }
//
//    override getPredicate(EObject context, EReference reference) {
//        val methodName = "scope_" + reference.EContainingClass.name + "_" + reference.name
//        println(methodName + " with context " + context.eClass.name)
//        return PolymorphicDispatcher.Predicates.forName(methodName, 2)
//    }
    
    def IScope scope_Type(EObject context, EReference reference) {
        if (umlContext == null) {
            IScope.NULLSCOPE
        } else {
            Scopes.scopeFor(umlContext.knownTypes)
        }
    }
    
    def IScope scope_Classifier(EObject context, EReference reference) {
        Scopes.scopeFor(
            umlContext.knownClasses,
            Scopes.scopeFor(umlContext.knownSignals)
        )
    }
    
    def IScope scope_Class(EObject context, EReference reference) {
        Scopes.scopeFor(umlContext.knownClasses)
    }
    
    def IScope scope_Signal(EObject context, EReference reference) {
        Scopes.scopeFor(umlContext.knownSignals)
    }
        
    def IScope scope_Association(EObject ctx, EReference ref) {
        Scopes.scopeFor(umlContext.knownAssociations)
    }
    
    def scope_NamedElement(Expression context, EReference reference) {
        val typeScope = scopeOfTypes
        val scope = scope_NamedElement(context, typeScope)
        scope
    }
    
    def IScope scope_NamedElement(EObject block) {
        scope_NamedElement(block, scopeOfTypes)    
    }
    
    def IScope scope_NamedElement(EObject block, IScope externalScope) {
        var parentBlock = block.eContainer
        if (parentBlock == null) {
            getParametersScope(externalScope)
        } else {
            val parentScope = scope_NamedElement(parentBlock, externalScope)
            val declarations = parentBlock.variableDeclarations(block)
            if (declarations.nullOrEmpty) {
                parentScope
            } else {
                Scopes.scopeFor(declarations, parentScope)
            }
        }
    }
    
    private def IScope scopeOfTypes() {
        Scopes.scopeFor(umlContext.knownTypes)
    }
    
    private def IScope getParametersScope(IScope parentScope) {
        val operation = umlContext.definedOperation
        if (operation == null) {
            parentScope
        } else {
            Scopes.scopeFor(operation.ownedParameters, parentScope)
        }
    }
    
    private def Iterable<Variable> variableDeclarations(EObject container, EObject until) {
        switch (container) {
          Block:
            // Assumes all variable instances are directly contained in a declaration statement  
            container.statement.
                takeWhile[it != until].
                filter[
                	// The loop variable of a for each statement should not be visible
                	!(it instanceof ForEachStatement)
                	// It is not necessary to filter ForStatement as its variable is not directly contained
                ].
                map[eContents.filter(Variable)].
                flatten
          Statements: container.statement.
                takeWhile[it != until].
                map[eContents.filter(Variable)].
                flatten
          ForStatement: variableDeclarations(container.initialization, container)
          ForEachStatement : newArrayList(container.variableDefinition)
          FilterExpression : newArrayList(container.declaration)
          Statement: 
            container.eContents.
                takeWhile[it != until].
                filter(Variable)
          default:
            emptyList
        }
    }
    
    private def getClassFromTypeReference(IUMLTypeReference typeRef) {
        if (typeRef instanceof UMLTypeReference) {
            val type = typeRef.umlType
            if (type instanceof Class) {
                return type
            }    
        }
        return null
    }
     
    def IScope scope_FeatureInvocationExpression_operation(FeatureInvocationExpression ctx, EReference ref) {
        if (ctx.context != null && !ctx.context.eIsProxy) {
            scope_FeatureInvocationExpression_operation(ctx.context, ref)    
        } else {
            null
        }
    }
    
    def IScope scope_FeatureInvocationExpression_operation(Expression ctx, EReference ref) {
        val typeResult = system.type(ctx)
        if (typeResult.failed) {
            return null
        }
        val type = typeResult.value.classFromTypeReference
        if (type != null) {
            Scopes.scopeFor(umlContext.getOperationsOfClass(type))
        } else {
            null
        }
    }
    
    def IScope scope_StaticFeatureInvocationExpression_operation(StaticFeatureInvocationExpression ctx, EReference ref) {
        Scopes.scopeFor(umlContext.getStaticOperations(),
            //XXX is this name conversion correct?
            [nameConverter.toQualifiedName('''«namespace.name»::«name»''')],
            IScope.NULLSCOPE
        )
    }
    
    def IScope scope_PropertyAccessExpression_property(PropertyAccessExpression ctx, EReference ref) {
        if (ctx.context != null && !(ctx.context.eIsProxy)) {
            scope_PropertyAccessExpression_property(ctx.context, ref)
        } else {
            null
        }
    }
    
    def IScope scope_PropertyAccessExpression_property(Expression ctx, EReference ref) {
        val typeResult = system.type(ctx)
        if (typeResult.failed) {
            return null
        }
        val type = typeResult.value.classFromTypeReference
        if (type != null) {
            return Scopes.scopeFor(umlContext.getPropertiesOfClass(type))
        }
        return null
    }
    
    def IScope scope_AssociationAccessExpression_association(AssociationAccessExpression ctx, EReference ref) {
        if (ctx.context != null && !(ctx.context.eIsProxy)) {
            scope_AssociationAccessExpression_association(ctx.context, ref)
        } else {
            null
        }
    }
    
    def IScope scope_AssociationAccessExpression_association(Expression ctx, EReference ref) {
        val typeResult = system.type(ctx)
        if (typeResult.failed) {
            return null
        }
        val typeRef = typeResult.value
        if (typeRef instanceof UMLTypeReference) {
            val type = typeRef.umlType
            if (type instanceof Class) {
                return Scopes.scopeFor(umlContext.getAssociationsOfClass(type))
            } 
        }
        return null
    }

}
